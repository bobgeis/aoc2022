==== All Days at #5055daf ====
-- optimized release

Day 0 for in/i00.txt
  Prep:  0.12ms
  Pt 1:  0.00ms ✅ 1
  Pt 2:  0.00ms ✅ 2
  Pt 3:  0.00ms ❓ 3
  Pt4a:  0.02ms ❌ wrong -> right
  Discussion:
    d00 is a simple example.
    It's time represents a lower bound for a day.
  Time:  0.26ms

Day 1 for in/i01.txt
  Prep:  0.33ms
  Pt 1:  0.00ms ✅ 68923
  Pt 2:  0.00ms ✅ 200044
  Time:  0.39ms

Day 2 for in/i02.txt
  Prep:  0.20ms
  Pt 1:  0.00ms ✅ 12276
  Pt 2:  0.00ms ✅ 9975
  Time:  0.24ms

Day 3 for in/i03.txt
  Prep:  0.19ms
  Pt 1:  0.09ms ✅ 7691
  Pt 2:  0.03ms ✅ 2508
  Time:  0.34ms

Day 4 for in/i04.txt
  Prep:  0.25ms
  Pt 1:  0.00ms ✅ 462
  Pt 2:  0.01ms ✅ 835
  Time:  0.34ms

Day 5 for in/i05.txt
  Prep:  0.18ms
  Pt 1:  0.02ms ✅ SHMSDGZVC
  Pt 2:  0.09ms ✅ VRZGHDFBQ
  Time:  0.32ms

Day 6 for in/i06.txt
  Prep:  0.03ms
  Pt 1:  0.05ms ✅ 1210
  Pt 2:  0.23ms ✅ 3476
  Time:  0.35ms

Day 7 for in/i07.txt
  Prep:  0.33ms
  Pt 1:  0.01ms ✅ 1908462
  Pt 2:  0.00ms ✅ 3979145
  Discussion:
    The input recursively walks the dirs, calling `ls` exactly once
    in each. It could have been much worse!
  Time:  0.39ms

Day 8 for in/i08.txt
  Prep:  1.22ms
  Pt 1:  0.46ms ✅ 1854
  Pt 2:  0.50ms ✅ 527340
  Time:  2.24ms

Day 9 for in/i09.txt
  Prep:  0.36ms
  Pt 1:  0.99ms ✅ 6243
  Pt 2:  0.51ms ✅ 2630
  Time:  1.90ms

Day 10 for in/i10.txt
  Prep:  0.08ms
  Pt 1:  0.00ms ✅ 12980
  Pt 2:  0.00ms ✅ BRJLFULP
  Time:  0.11ms

Day 11 for in/i11.txt
  Prep:  0.30ms
  Pt 1:  0.03ms ✅ 110264
  Pt 2: 20.76ms ✅ 23612457316
  Time: 21.16ms

Day 12 for in/i12.txt
  Prep:  1.24ms
  Pt 1:  4.60ms ✅ 534
  Pt 2:  3.32ms ✅ 525
  Discussion:
    A chance to use graphwalk.bfs!

    There was a bug with my initial implementation that made part 1
    take way too long.

    There's still lots of room for improvement, but it works decently
    for now.
  Time:  9.32ms

Day 13 for in/i13.txt
  Prep:  1.50ms
  Pt 1:  0.06ms ✅ 5557
  Pt 2:  0.68ms ✅ 22425
  Discussion:
    First thought: Can we walk the pairs of strings comparing them
    char by char?

    Second thought: Can we somehow use pegs here?

    Third thought: This is all valid json, let's just parse it!

    I hadn't used the std/json library before, so that took some
    experimentation. Once finished, it worked great and part 2 was
    very quick to code.

    It may be possible to improve performance by using a faster json
    library. Several exist (eg search the nim forum).
  Time:  2.32ms

==== Total Time: 0.041 s ====
