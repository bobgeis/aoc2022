==== All Days at #4693350 ====
-- optimized release

Day 0 for in/i00.txt
  Prep:  0.19ms
  Pt 1:  0.01ms ✅ 1
  Pt 2:  0.00ms ✅ 2
  Pt 3:  0.00ms ❓ 3
  Pt 4:  0.01ms ❌ wrong -> right
  Discussion:
    d00 is a simple example.
    It's time represents a lower bound for a day.
    
  Time:  0.34ms

Day 1 for in/i01.txt
  Pt 1:  0.01ms ✅ 68923
  Pt 2:  0.00ms ✅ 200044
  Time:  0.45ms

Day 2 for in/i02.txt
  Pt 1:  0.01ms ✅ 12276
  Pt 2:  0.00ms ✅ 9975
  Time:  0.27ms

Day 3 for in/i03.txt
  Pt 1:  0.10ms ✅ 7691
  Pt 2:  0.03ms ✅ 2508
  Time:  0.44ms

Day 4 for in/i04.txt
  Pt 1:  0.00ms ✅ 462
  Pt 2:  0.00ms ✅ 835
  Time:  0.26ms

Day 5 for in/i05.txt
  Pt 1:  0.02ms ✅ SHMSDGZVC
  Pt 2:  0.09ms ✅ VRZGHDFBQ
  Time:  0.40ms

Day 6 for in/i06.txt
  Pt 1:  0.06ms ✅ 1210
  Pt 2:  0.23ms ✅ 3476
  Time:  0.38ms

Day 7 for in/i07.txt
  Pt 0:  0.00ms ❓ The input recursively walks the dirs,
    calling `ls` exactly once in each.
    It could have been much worse!
  Pt 1:  0.01ms ✅ 1908462
  Pt 2:  0.00ms ✅ 3979145
  Time:  0.38ms

Day 8 for in/i08.txt
  Pt 1:  0.43ms ✅ 1854
  Pt 2:  0.53ms ✅ 527340
  Time:  2.46ms

Day 9 for in/i09.txt
  Pt 1:  0.99ms ✅ 6243
  Pt 2:  0.52ms ✅ 2630
  Time:  2.04ms

Day 10 for in/i10.txt
  Pt 1:  0.00ms ✅ 12980
  Pt 2:  0.00ms ✅ BRJLFULP
  Time:  0.13ms

Day 11 for in/i11.txt
  Pt 1:  0.03ms ✅ 110264
  Pt 2: 22.66ms ✅ 23612457316
  Time: 23.67ms

Day 12 for in/i12.txt
  Prep:  1.02ms
  Pt 1:  3.48ms ✅ 534
  Pt 2:  3.06ms ✅ 525
  Discussion:
    A chance to use graphwalk.bfs!

    There was a bug with my initial implementation that
    made part 1 take way too long.

    There's still lots of room for improvement, but it works
    decently for now.
  
  Time:  7.68ms

Day 13 for in/i13.txt
  Prep:  2.29ms
  Pt 1:  0.13ms ✅ 5557
  Pt 2:  2.22ms ✅ 22425
  Discussion:
    First thought: Can we walk the pairs of strings comparing
    them char by char?

    Second thought: Can we somehow use pegs here?

    Third thought: This is all valid json, let's parse it!

    I hadn't used the std/json library before, so that took some
    experimentation. Once finished, it worked great and part 2
    was very quick to code.

    It may be possible to improve performance by using a faster
    json library. Several exist (eg search the nim forum).

    
  Time:  4.81ms

==== Total Time: 0.045 s ====
