==== All Days at #77dab11 ====
-- optimized release

Day 0 for in/i00.txt
  Prep:  0.11ms
  Pt 1:  0.00ms ✅ 1
  Pt 2:  0.00ms ✅ 2
  Pt 3:  0.00ms ❓ 3
  Pt4a:  0.01ms ❌ wrong -> right
  Discussion:
    d00 is a trival example. It's time represents a noisy lower bound
    for a day.
  Time:  0.21ms

Day 1 for in/i01.txt
  Prep:  0.35ms
  Pt 1:  0.00ms ✅ 68923
  Pt 2:  0.00ms ✅ 200044
  Time:  0.41ms

Day 2 for in/i02.txt
  Prep:  0.21ms
  Pt 1:  0.00ms ✅ 12276
  Pt 2:  0.00ms ✅ 9975
  Time:  0.26ms

Day 3 for in/i03.txt
  Prep:  0.27ms
  Pt 1:  0.09ms ✅ 7691
  Pt 2:  0.03ms ✅ 2508
  Time:  0.43ms

Day 4 for in/i04.txt
  Prep:  0.22ms
  Pt 1:  0.00ms ✅ 462
  Pt 2:  0.00ms ✅ 835
  Time:  0.26ms

Day 5 for in/i05.txt
  Prep:  0.23ms
  Pt 1:  0.02ms ✅ SHMSDGZVC
  Pt 2:  0.09ms ✅ VRZGHDFBQ
  Time:  0.38ms

Day 6 for in/i06.txt
  Prep:  0.07ms
  Pt 1:  0.05ms ✅ 1210
  Pt 2:  0.23ms ✅ 3476
  Time:  0.39ms

Day 7 for in/i07.txt
  Prep:  0.33ms
  Pt 1:  0.00ms ✅ 1908462
  Pt 2:  0.00ms ✅ 3979145
  Discussion:
    The input recursively walks the dirs, calling `ls` exactly once
    in each. It could have been much worse!
  Time:  0.38ms

Day 8 for in/i08.txt
  Prep:  1.26ms
  Pt 1:  0.36ms ✅ 1854
  Pt 2:  0.49ms ✅ 527340
  Time:  2.16ms

Day 9 for in/i09.txt
  Prep:  0.49ms
  Pt 1:  0.92ms ✅ 6243
  Pt 2:  0.49ms ✅ 2630
  Time:  1.94ms

Day 10 for in/i10.txt
  Prep:  0.11ms
  Pt 1:  0.00ms ✅ 12980
  Pt 2:  0.01ms ✅ BRJLFULP
  Time:  0.15ms

Day 11 for in/i11.txt
  Prep:  0.81ms
  Pt 1:  0.03ms ✅ 110264
  Pt 2: 20.45ms ✅ 23612457316
  Time: 21.37ms

Day 12 for in/i12.txt
  Prep:  0.96ms
  Pt 1:  3.85ms ✅ 534
  Pt 2:  3.23ms ✅ 525
  Discussion:
    A chance to use graphwalk.bfs!

    There was a bug with my initial implementation that made part 1
    take way too long.

    There's still lots of room for improvement, but it works decently
    for now.
  Time:  8.14ms

Day 13 for in/i13.txt
  Prep:  1.66ms
  Pt 1:  0.04ms ✅ 5557
  Pt 2:  0.53ms ✅ 22425
  Discussion:
    First thought: Can we walk the pairs of strings comparing them
    char by char?

    Second thought: Can we somehow use pegs here?

    Third thought: This is all valid json, let's just parse it!

    I hadn't used the std/json library before, so that took some
    experimentation. Once finished, it worked great and part 2 was
    very quick to code.

    It may be possible to improve performance by using a faster json
    library. Several exist (eg search the nim forum).
  Time:  2.27ms

==== Total Time:  39.45ms ====
